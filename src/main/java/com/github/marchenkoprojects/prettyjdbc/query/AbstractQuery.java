package com.github.marchenkoprojects.prettyjdbc.query;

import com.github.marchenkoprojects.prettyjdbc.Unwrapable;
import com.github.marchenkoprojects.prettyjdbc.query.scrollable_result.CachedScrollableResult;
import com.github.marchenkoprojects.prettyjdbc.query.scrollable_result.ReadOnlyScrollableResult;

import java.math.BigDecimal;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * This abstraction is the base parent for all types of queries.
 * The <code>AbstractQuery</code> implements the necessary methods to execute a single query into the database.
 * It extends the capabilities of the standard abstraction {@link java.sql.PreparedStatement}.
 * The lifecycle of any implementation is very short and starts with the method {@link com.github.marchenkoprojects.prettyjdbc.session.Session#createQuery(String)}.
 * <br>
 * To perform a native SQL query, use the method {@link AbstractQuery#execute()} which will return the result as {@link ReadOnlyScrollableResult};
 * to <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> the data, use the method {@link AbstractQuery#executeUpdate()};
 * to perform a batched query, use the method {@link AbstractQuery#addBatch()} to add a batch and {@link AbstractQuery#executeBatch()} to apply it.
 *
 * @param <Q> the type of specific query implementation
 *
 * @author Oleg Marchenko
 *
 * @see ReadOnlyScrollableResult
 */
public abstract class AbstractQuery<Q> implements Unwrapable<PreparedStatement>, AutoCloseable, IndexedParameterQuerySetter<Q> {

    protected final PreparedStatement preparedStatement;

    protected AbstractQuery(PreparedStatement preparedStatement) {
        this.preparedStatement = preparedStatement;
    }

    /**
     * Returns the specific query instance.
     * Used to return from parameter setting methods to be able to work with a call chain.
     *
     * @return the specific query instance
     */
    protected abstract Q getInstance();

    /**
     * Unwrapping {@link PreparedStatement} from the specific query implementation for use outside.
     *
     * @return wrapped <code>PreparedStatement</code>
     */
    @Override
    public PreparedStatement unwrap() {
        return preparedStatement;
    }

    /**
     * Executes the SQL query and returns the {@link ReadOnlyScrollableResult} object generated by the query.
     *
     * @return a <code>ReadOnlyScrollableResult</code> object that contains the data produced by the query
     * @throws RuntimeException if a database access error occurs
     */
    public ReadOnlyScrollableResult execute() {
        try (ResultSet result = preparedStatement.executeQuery()) {
            return new CachedScrollableResult(result);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Executes the SQL query, which must be an SQL Data Manipulation Language (DML) statement,
     * such as <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code>;
     * or an SQL statement that returns nothing, such as a DDL statement.
     *
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
     *         or (2) 0 for SQL statements that return nothing
     * @throws RuntimeException if a database access error occurs
     */
    public int executeUpdate() {
        try {
            return preparedStatement.executeUpdate();
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Adds a set of parameters to this <code>Query</code> object's batch of commands.
     *
     * @return instance of the specific query
     * @throws RuntimeException if a database access error occurs
     */
    public Q addBatch() {
        try {
            preparedStatement.addBatch();
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * Submits a batch of commands to the database for execution and
     * if all commands execute successfully, returns an array of update counts.
     *
     * @return an array of update counts containing one element for each
     *         command in the batch
     * @throws RuntimeException if a database access error occurs
     */
    public int[] executeBatch() {
        try {
            return preparedStatement.executeBatch();
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Returns <code>true</code> if the query is still active.
     * The query remains active until the method {@link com.github.marchenkoprojects.prettyjdbc.session.Session#close()} has been called on it
     * or certain fatal errors have not occurred.
     *
     * @return <code>true</code> if this <code>Query</code> object is still active;
     *         <code>false</code> if it is inactive
     * @throws RuntimeException if a database access error occurs
     */
    public boolean isActive() {
        try {
            return !preparedStatement.isClosed();
        }
        catch (SQLException e) {
            return false;
        }
    }

    /**
     * Releases the internal {@link PreparedStatement} object and JDBC resources immediately,
     * instead of waiting for the automatic closing to occur.
     *
     * @exception SQLException if a database access error occurs
     */
    @Override
    public void close() throws SQLException {
        preparedStatement.close();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, boolean value) {
        try {
            preparedStatement.setBoolean(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, byte value) {
        try {
            preparedStatement.setByte(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, short value) {
        try {
            preparedStatement.setShort(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, int value) {
        try {
            preparedStatement.setInt(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, long value) {
        try {
            preparedStatement.setLong(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, float value) {
        try {
            preparedStatement.setFloat(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, double value) {
        try {
            preparedStatement.setDouble(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, BigDecimal value) {
        try {
            preparedStatement.setBigDecimal(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, String value) {
        try {
            preparedStatement.setString(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, byte[] value) {
        try {
            preparedStatement.setBytes(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, Date value) {
        try {
            preparedStatement.setDate(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, LocalDate value) {
        Date date = null;
        if (value != null) {
            date = Date.valueOf(value);
        }
        return setParameter(paramIndex, date);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, Time value) {
        try {
            preparedStatement.setTime(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, LocalTime value) {
        Time time = null;
        if (value != null) {
            time = Time.valueOf(value);
        }
        return setParameter(paramIndex, time);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, Timestamp value) {
        try {
            preparedStatement.setTimestamp(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, LocalDateTime value) {
        Timestamp timestamp = null;
        if (value != null) {
            timestamp = Timestamp.valueOf(value);
        }
        return setParameter(paramIndex, timestamp);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Q setParameter(int paramIndex, Object value) {
        try {
            preparedStatement.setObject(paramIndex, value);
        }
        catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return getInstance();
    }

    /**
     * Allows to immediately close the query, protecting against possible exceptions.
     *
     * @param query the query to close
     *
     * @see AbstractQuery#close()
     */
    public static void closeQuerySoftly(AbstractQuery<?> query) {
        if (query != null && query.isActive()) {
            try {
                query.close();
            }
            catch (SQLException e) {
                // Intentionally swallow the exception.
                // TODO: Add the warning after adding logging library.
            }
        }
    }
}
